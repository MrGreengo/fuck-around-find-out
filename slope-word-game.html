<!DOCTYPE html>
<html>
<head>
  <title>Rolling Ball Game</title>
  <style>
    body { margin: 0; background: black; }
    canvas { display: block; }
    #score {
      position: fixed;
      top: 20px;
      left: 20px;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 24px;
      z-index: 100;
    }
    #gameOver {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: Arial, sans-serif;
      font-size: 48px;
      display: none;
      z-index: 100;
      text-align: center;
      background: rgba(0, 0, 0, 0.7);
      padding: 20px;
      border-radius: 10px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="gameOver">Game Over!<br>Click to restart</div>
  
  <!-- Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    /*********************
     * Global Variables
     *********************/
    let camera, scene, renderer, ball;
    let paths = [];
    let obstacles = [];
    let score = 0;
    let gameActive = true;
    let isFalling = false;
    let lastPathZ = 0;
    let ballVelocity = { x: 0, y: 0, z: 0.3 };
    let touchStartX = 0;

    const BALL_RADIUS = 0.5;
    const SEGMENT_LENGTH = 30;
    const PATH_WIDTH = 15;
    const BALL_SPEED = 0.3;
    const BASE_FORWARD_SPEED = 0.3;

    /*********************
     * Word Library
     *
     * Each set is an object with a correct word and an array of two misspellings.
     *********************/
    const wordLibrary = [
      { correct: "cat",  incorrect: ["cit", "cet"] },
      { correct: "dog",  incorrect: ["dug", "dgo"] },
      { correct: "sun",  incorrect: ["son", "snu"] },
      { correct: "car",  incorrect: ["cra", "acr"] },
      { correct: "book", incorrect: ["bokk", "buk"] }
    ];

    /*********************
     * Utility Functions
     *********************/
    // Returns the terrain height at z using sine waves.
    function getHeightAt(z) {
      const baseHeight = Math.sin(z * 0.05) * 2;
      const variation = Math.sin(z * 0.1) * 1;
      return baseHeight + variation;
    }
    // Returns the slope angle by comparing two nearby heights.
    function getSlopeAngleAt(z) {
      const h1 = getHeightAt(z);
      const h2 = getHeightAt(z + 0.1);
      return Math.atan2(h2 - h1, 0.1);
    }
    // Creates a simple path geometry from startZ.
    function createPathGeometry(startZ) {
      const segments = 20;
      const positions = [];
      const uvs = [];
      for (let i = 0; i <= segments; i++) {
        const z = startZ + (i / segments) * SEGMENT_LENGTH;
        const nextZ = startZ + ((i + 1) / segments) * SEGMENT_LENGTH;
        const y1 = getHeightAt(z);
        const y2 = getHeightAt(nextZ);
        if (i < segments) {
          // Two triangles per segment.
          positions.push(
            -PATH_WIDTH/2, y1, z,
             PATH_WIDTH/2, y1, z,
            -PATH_WIDTH/2, y2, nextZ,

             PATH_WIDTH/2, y1, z,
             PATH_WIDTH/2, y2, nextZ,
            -PATH_WIDTH/2, y2, nextZ
          );
          for (let j = 0; j < 6; j++) {
            uvs.push(j % 2, Math.floor(j / 2) % 2);
          }
        }
      }
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      geometry.computeVertexNormals();
      return geometry;
    }
    // Creates a text sprite from a canvas texture.
    function createTextSprite(message, parameters) {
      parameters = parameters || {};
      const fontface = parameters.fontface || "Arial";
      const fontsize = parameters.fontsize || 18;
      const borderThickness = parameters.borderThickness || 4;
      const borderColor = parameters.borderColor || { r: 0, g: 0, b: 0, a: 1.0 };
      const backgroundColor = parameters.backgroundColor || { r: 255, g: 255, b: 255, a: 1.0 };

      // Measure text width using a temporary canvas.
      const tempCanvas = document.createElement("canvas");
      const tempContext = tempCanvas.getContext("2d");
      tempContext.font = fontsize + "px " + fontface;
      const metrics = tempContext.measureText(message);
      const textWidth = metrics.width;

      // Create the actual canvas.
      const canvas = document.createElement("canvas");
      canvas.width = textWidth + borderThickness * 2;
      canvas.height = fontsize * 1.4 + borderThickness * 2;
      const context = canvas.getContext("2d");
      context.font = fontsize + "px " + fontface;

      // Draw background and border.
      context.fillStyle = `rgba(${backgroundColor.r},${backgroundColor.g},${backgroundColor.b},${backgroundColor.a})`;
      context.fillRect(0, 0, canvas.width, canvas.height);
      context.strokeStyle = `rgba(${borderColor.r},${borderColor.g},${borderColor.b},${borderColor.a})`;
      context.lineWidth = borderThickness;
      context.strokeRect(0, 0, canvas.width, canvas.height);

      // Draw the text.
      context.fillStyle = "rgba(0, 0, 0, 1.0)";
      context.textAlign = "center";
      context.textBaseline = "middle";
      context.fillText(message, canvas.width/2, canvas.height/2);

      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(5, 2.5, 1.0);
      return sprite;
    }

    /*********************
     * Initialization
     *********************/
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Lighting.
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(10, 20, 10);
      scene.add(dirLight);

      // Create the ball (with a grid‐pattern texture).
      const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
      const ballTexture = createBallTexture();
      const ballMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, map: ballTexture });
      ball = new THREE.Mesh(ballGeometry, ballMaterial);
      ball.position.set(0, BALL_RADIUS + getHeightAt(0), 0);
      scene.add(ball);

      // Create initial path segments.
      for (let i = 0; i < 4; i++) {
        createPathSegment(lastPathZ);
        lastPathZ += SEGMENT_LENGTH;
      }
      updateCamera();
    }
    // Creates a grid texture for the ball.
    function createBallTexture() {
      const canvas = document.createElement("canvas");
      canvas.width = 64;
      canvas.height = 64;
      const context = canvas.getContext("2d");
      context.fillStyle = "#ff0000";
      context.fillRect(0, 0, 64, 64);
      context.strokeStyle = "#ffffff";
      context.lineWidth = 2;
      for (let i = 0; i < 64; i += 16) {
        context.beginPath();
        context.moveTo(i, 0);
        context.lineTo(i, 64);
        context.stroke();
        context.beginPath();
        context.moveTo(0, i);
        context.lineTo(64, i);
        context.stroke();
      }
      return new THREE.CanvasTexture(canvas);
    }

    /*********************
     * Creating a Path Segment and Obstacles
     *
     * For obstacles we randomly either create a cube (full collider)
     * or a triple arch obstacle. For the triple arch, we build three separate
     * arch sub-groups – one of which is passable (true) and the other two are false.
     * Each arch gets a text sprite with one of three words chosen from our library.
     *********************/
    function createPathSegment(startZ) {
      const geometry = createPathGeometry(startZ);
      const material = new THREE.MeshPhongMaterial({
        color: 0x808080,
        side: THREE.DoubleSide,
        wireframe: false
      });
      const path = new THREE.Mesh(geometry, material);
      scene.add(path);
      paths.push(path);

      // Remove old paths.
      if (paths.length > 5) {
        scene.remove(paths[0]);
        paths.shift();
      }

      // Determine the obstacle location and slope.
      const obsZ = startZ + SEGMENT_LENGTH/2;
      const obsHeight = getHeightAt(obsZ);
      const slopeAngle = getSlopeAngleAt(obsZ);

      if (Math.random() > 0.3) {
        if (Math.random() > 0.5) {
          // Create a cube obstacle (full collider).
          const obstacleWidth = PATH_WIDTH * 0.15;
          const cube = new THREE.Mesh(
            new THREE.BoxGeometry(obstacleWidth, 2, 1),
            new THREE.MeshPhongMaterial({ color: 0x0000ff })
          );
          cube.position.set(
            (Math.random()-0.5) * (PATH_WIDTH-obstacleWidth),
            obsHeight+1,
            obsZ
          );
          cube.rotation.x = slopeAngle;
          cube.userData.isFullCollider = true;
          scene.add(cube);
          obstacles.push(cube);
        } else {
          // Create a triple arch obstacle.
          // We will create three separate arch items inside an archGroup.
          const archGroup = new THREE.Group();
          const archHeight = 3;
          const archWidth = PATH_WIDTH * 0.2; // opening width per arch.
          const pillarWidth = 0.5;
          const archDepth = 1;
          const spacing = archWidth + pillarWidth; // horizontal spacing.

          // First, choose a random word set from our library.
          const chosenSet = wordLibrary[Math.floor(Math.random()*wordLibrary.length)];
          // We need one correct word and two incorrect ones.
          // Copy the two false words.
          const falseWords = chosenSet.incorrect.slice();
          // Randomly choose which arch (0, 1, or 2) will be passable.
          const trueIndex = Math.floor(Math.random()*3);
          // Prepare an array of words for the three arches.
          const archWords = [];
          for (let i = 0; i < 3; i++) {
            if (i === trueIndex) {
              archWords.push(chosenSet.correct);
            } else {
              // Remove one false word.
              archWords.push(falseWords.shift());
            }
          }

          // Create three arch sub-groups.
          // We'll loop with i from -1 to 1 so that (i+1) is 0,1,2.
          for (let i = -1; i <= 1; i++) {
            const archItem = new THREE.Group();
            const index = i + 1; // 0, 1, or 2.
            // Mark this arch as passable (true) if its index equals trueIndex.
            archItem.userData.passable = (index === trueIndex);

            // Create the pillars and top arch for this arch.
            // Left pillar.
            const leftPillar = new THREE.Mesh(
              new THREE.BoxGeometry(pillarWidth, archHeight, archDepth),
              new THREE.MeshPhongMaterial({ color: 0x8B0000 })
            );
            leftPillar.position.set(i * spacing - archWidth/2 - pillarWidth/2, archHeight/2, 0);
            leftPillar.userData.isPillar = true;
            archItem.add(leftPillar);
            // Right pillar.
            const rightPillar = new THREE.Mesh(
              new THREE.BoxGeometry(pillarWidth, archHeight, archDepth),
              new THREE.MeshPhongMaterial({ color: 0x8B0000 })
            );
            rightPillar.position.set(i * spacing + archWidth/2 + pillarWidth/2, archHeight/2, 0);
            rightPillar.userData.isPillar = true;
            archItem.add(rightPillar);
            // Top arch (the horizontal beam).
            const topArch = new THREE.Mesh(
              new THREE.BoxGeometry(archWidth + pillarWidth*2, pillarWidth, archDepth),
              new THREE.MeshPhongMaterial({ color: 0x8B0000 })
            );
            topArch.position.set(i * spacing, archHeight, 0);
            topArch.userData.isPillar = true;
            archItem.add(topArch);

            // Create the text sprite for this arch using its assigned word.
            const textSprite = createTextSprite(archWords[index], {
              fontface: "Arial",
              fontsize: 24,
              borderThickness: 2,
              borderColor: { r: 0, g: 0, b: 255, a: 1.0 },
              backgroundColor: { r: 255, g: 255, b: 255, a: 0.5 }
            });
            // Position the text above the arch.
            textSprite.position.set(0, archHeight + 1, 0);
            archItem.add(textSprite);

            // Add this arch item to the archGroup.
            archGroup.add(archItem);
          }

          // Mark the entire group as a triple arch obstacle.
          archGroup.userData.isTripleArch = true;
          archGroup.position.set(0, obsHeight, obsZ);
          archGroup.rotation.x = slopeAngle;
          scene.add(archGroup);
          obstacles.push(archGroup);
        }

        // Remove old obstacles.
        if (obstacles.length > 10) {
          scene.remove(obstacles[0]);
          obstacles.shift();
        }
      }
    }

    /*********************
     * Camera and Ball Updates
     *********************/
    function updateCamera() {
      const slopeAngle = getSlopeAngleAt(ball.position.z);
      const lookAheadDistance = 10;
      camera.position.z = ball.position.z - lookAheadDistance * Math.cos(slopeAngle);
      camera.position.y = ball.position.y + 5 - lookAheadDistance * Math.sin(slopeAngle);
      camera.position.x = ball.position.x;
      const targetPoint = new THREE.Vector3(
        ball.position.x,
        ball.position.y + Math.sin(slopeAngle) * 2,
        ball.position.z + Math.cos(slopeAngle) * 2
      );
      camera.lookAt(targetPoint);
    }
    function updateBall() {
      if (!isFalling) {
        const slopeAngle = getSlopeAngleAt(ball.position.z);
        const forwardSpeed = BASE_FORWARD_SPEED * (1 - Math.sin(slopeAngle)*0.5);
        ball.position.x += ballVelocity.x;
        ball.position.z += forwardSpeed;
        const targetHeight = getHeightAt(ball.position.z) + BALL_RADIUS;
        ball.position.y = targetHeight;
        ball.rotation.x = slopeAngle;
        ball.rotation.z -= ballVelocity.x / BALL_RADIUS;
        ball.rotation.x -= forwardSpeed / BALL_RADIUS;
        if (Math.abs(ball.position.x) > PATH_WIDTH/2 - BALL_RADIUS) {
          isFalling = true;
          ballVelocity.y = 0;
        }
      } else {
        ballVelocity.y -= 0.015;
        ball.position.y += ballVelocity.y;
        ball.rotation.x += 0.1;
        ball.rotation.z += 0.1;
        if (ball.position.y < getHeightAt(ball.position.z) - 10) {
          gameActive = false;
          document.getElementById("gameOver").style.display = "block";
        }
      }
    }

    /*********************
     * Game Update and Collision Detection
     *
     * For cube obstacles we check collisions normally.
     * For triple arch obstacles we loop through each arch item;
     * if an arch is not passable (a false arch) then collision with any of its pillars triggers game over.
     *********************/
    function updateGame() {
      updateBall();
      updateCamera();
      if (ball.position.z > lastPathZ - SEGMENT_LENGTH*2) {
        createPathSegment(lastPathZ);
        lastPathZ += SEGMENT_LENGTH;
      }
      if (!isFalling) {
        score++;
        document.getElementById("score").textContent = `Score: ${score}`;
      }
      // Collision detection.
      const ballBox = new THREE.Box3().setFromObject(ball);
      obstacles.forEach(obstacle => {
        if (obstacle.userData.isFullCollider) {
          const obsBox = new THREE.Box3().setFromObject(obstacle);
          if (ballBox.intersectsBox(obsBox)) {
            gameActive = false;
            document.getElementById("gameOver").style.display = "block";
          }
        } else if (obstacle.userData.isTripleArch) {
          // For each arch item, only check false arches.
          obstacle.children.forEach(archItem => {
            if (!archItem.userData.passable) {
              archItem.children.forEach(child => {
                if (child.userData.isPillar) {
                  const childBox = new THREE.Box3().setFromObject(child);
                  if (ballBox.intersectsBox(childBox)) {
                    gameActive = false;
                    document.getElementById("gameOver").style.display = "block";
                  }
                }
              });
            }
          });
        }
      });
    }

    /*********************
     * Reset and Animation
     *********************/
    function resetGame() {
      ball.position.set(0, BALL_RADIUS + getHeightAt(0), 0);
      ball.rotation.set(0, 0, 0);
      ballVelocity = { x: 0, y: 0, z: BASE_FORWARD_SPEED };
      isFalling = false;
      gameActive = true;
      score = 0;
      document.getElementById("score").textContent = "Score: 0";
      document.getElementById("gameOver").style.display = "none";
      paths.forEach(path => scene.remove(path));
      obstacles.forEach(obs => scene.remove(obs));
      paths = [];
      obstacles = [];
      lastPathZ = 0;
      for (let i = 0; i < 4; i++) {
        createPathSegment(lastPathZ);
        lastPathZ += SEGMENT_LENGTH;
      }
    }
    function animate() {
      requestAnimationFrame(animate);
      if (gameActive) { updateGame(); }
      renderer.render(scene, camera);
    }

    /*********************
     * Input Handlers
     *********************/
    function onKeyDown(event) {
      if (!gameActive || isFalling) return;
      if (event.key === "ArrowLeft") {
        ballVelocity.x = -BALL_SPEED;
      } else if (event.key === "ArrowRight") {
        ballVelocity.x = BALL_SPEED;
      }
    }
    function onKeyUp(event) {
      if (event.key === "ArrowLeft" || event.key === "ArrowRight") {
        ballVelocity.x = 0;
      }
    }
    function handleTouchStart(event) {
      if (!gameActive || isFalling) return;
      touchStartX = event.touches[0].clientX;
    }
    function handleTouchMove(event) {
      if (!gameActive || isFalling) return;
      const touchX = event.touches[0].clientX;
      const diff = touchX - touchStartX;
      ballVelocity.x = diff > 0 ? -BALL_SPEED : BALL_SPEED;
      touchStartX = touchX;
    }
    function handleTouchEnd() {
      ballVelocity.x = 0;
    }

    /*********************
     * Start the Game
     *********************/
    init();
    animate();
    window.addEventListener("keydown", onKeyDown);
    window.addEventListener("keyup", onKeyUp);
    window.addEventListener("touchstart", handleTouchStart);
    window.addEventListener("touchmove", handleTouchMove);
    window.addEventListener("touchend", handleTouchEnd);
    document.getElementById("gameOver").addEventListener("click", resetGame);
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
